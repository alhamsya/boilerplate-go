// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"

	testing "testing"
)

// UtilsRepo is an autogenerated mock type for the UtilsRepo type
type UtilsRepo struct {
	mock.Mock
}

type UtilsRepo_Expecter struct {
	mock *mock.Mock
}

func (_m *UtilsRepo) EXPECT() *UtilsRepo_Expecter {
	return &UtilsRepo_Expecter{mock: &_m.Mock}
}

// CheckPasswordHash provides a mock function with given fields: password, hash
func (_m *UtilsRepo) CheckPasswordHash(password string, hash string) bool {
	ret := _m.Called(password, hash)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(password, hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// UtilsRepo_CheckPasswordHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPasswordHash'
type UtilsRepo_CheckPasswordHash_Call struct {
	*mock.Call
}

// CheckPasswordHash is a helper method to define mock.On call
//  - password string
//  - hash string
func (_e *UtilsRepo_Expecter) CheckPasswordHash(password interface{}, hash interface{}) *UtilsRepo_CheckPasswordHash_Call {
	return &UtilsRepo_CheckPasswordHash_Call{Call: _e.mock.On("CheckPasswordHash", password, hash)}
}

func (_c *UtilsRepo_CheckPasswordHash_Call) Run(run func(password string, hash string)) *UtilsRepo_CheckPasswordHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *UtilsRepo_CheckPasswordHash_Call) Return(_a0 bool) *UtilsRepo_CheckPasswordHash_Call {
	_c.Call.Return(_a0)
	return _c
}

// CurrentTimeF provides a mock function with given fields: format
func (_m *UtilsRepo) CurrentTimeF(format string) (string, error) {
	ret := _m.Called(format)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(format)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(format)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsRepo_CurrentTimeF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrentTimeF'
type UtilsRepo_CurrentTimeF_Call struct {
	*mock.Call
}

// CurrentTimeF is a helper method to define mock.On call
//  - format string
func (_e *UtilsRepo_Expecter) CurrentTimeF(format interface{}) *UtilsRepo_CurrentTimeF_Call {
	return &UtilsRepo_CurrentTimeF_Call{Call: _e.mock.On("CurrentTimeF", format)}
}

func (_c *UtilsRepo_CurrentTimeF_Call) Run(run func(format string)) *UtilsRepo_CurrentTimeF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *UtilsRepo_CurrentTimeF_Call) Return(_a0 string, _a1 error) *UtilsRepo_CurrentTimeF_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// Decrypt provides a mock function with given fields: passphrase, cipherText
func (_m *UtilsRepo) Decrypt(passphrase string, cipherText string) (string, error) {
	ret := _m.Called(passphrase, cipherText)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(passphrase, cipherText)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(passphrase, cipherText)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsRepo_Decrypt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decrypt'
type UtilsRepo_Decrypt_Call struct {
	*mock.Call
}

// Decrypt is a helper method to define mock.On call
//  - passphrase string
//  - cipherText string
func (_e *UtilsRepo_Expecter) Decrypt(passphrase interface{}, cipherText interface{}) *UtilsRepo_Decrypt_Call {
	return &UtilsRepo_Decrypt_Call{Call: _e.mock.On("Decrypt", passphrase, cipherText)}
}

func (_c *UtilsRepo_Decrypt_Call) Run(run func(passphrase string, cipherText string)) *UtilsRepo_Decrypt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *UtilsRepo_Decrypt_Call) Return(plainText string, err error) *UtilsRepo_Decrypt_Call {
	_c.Call.Return(plainText, err)
	return _c
}

// Encrypt provides a mock function with given fields: passphrase, plaintext
func (_m *UtilsRepo) Encrypt(passphrase string, plaintext string) (string, error) {
	ret := _m.Called(passphrase, plaintext)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(passphrase, plaintext)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(passphrase, plaintext)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsRepo_Encrypt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Encrypt'
type UtilsRepo_Encrypt_Call struct {
	*mock.Call
}

// Encrypt is a helper method to define mock.On call
//  - passphrase string
//  - plaintext string
func (_e *UtilsRepo_Expecter) Encrypt(passphrase interface{}, plaintext interface{}) *UtilsRepo_Encrypt_Call {
	return &UtilsRepo_Encrypt_Call{Call: _e.mock.On("Encrypt", passphrase, plaintext)}
}

func (_c *UtilsRepo_Encrypt_Call) Run(run func(passphrase string, plaintext string)) *UtilsRepo_Encrypt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *UtilsRepo_Encrypt_Call) Return(cipherText string, err error) *UtilsRepo_Encrypt_Call {
	_c.Call.Return(cipherText, err)
	return _c
}

// HashPassword provides a mock function with given fields: password
func (_m *UtilsRepo) HashPassword(password string) (string, error) {
	ret := _m.Called(password)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(password)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsRepo_HashPassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashPassword'
type UtilsRepo_HashPassword_Call struct {
	*mock.Call
}

// HashPassword is a helper method to define mock.On call
//  - password string
func (_e *UtilsRepo_Expecter) HashPassword(password interface{}) *UtilsRepo_HashPassword_Call {
	return &UtilsRepo_HashPassword_Call{Call: _e.mock.On("HashPassword", password)}
}

func (_c *UtilsRepo_HashPassword_Call) Run(run func(password string)) *UtilsRepo_HashPassword_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *UtilsRepo_HashPassword_Call) Return(_a0 string, _a1 error) *UtilsRepo_HashPassword_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// ToMap provides a mock function with given fields: v
func (_m *UtilsRepo) ToMap(v interface{}) map[string]interface{} {
	ret := _m.Called(v)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(interface{}) map[string]interface{}); ok {
		r0 = rf(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	return r0
}

// UtilsRepo_ToMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ToMap'
type UtilsRepo_ToMap_Call struct {
	*mock.Call
}

// ToMap is a helper method to define mock.On call
//  - v interface{}
func (_e *UtilsRepo_Expecter) ToMap(v interface{}) *UtilsRepo_ToMap_Call {
	return &UtilsRepo_ToMap_Call{Call: _e.mock.On("ToMap", v)}
}

func (_c *UtilsRepo_ToMap_Call) Run(run func(v interface{})) *UtilsRepo_ToMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *UtilsRepo_ToMap_Call) Return(r map[string]interface{}) *UtilsRepo_ToMap_Call {
	_c.Call.Return(r)
	return _c
}

// ToStruct provides a mock function with given fields: v, r
func (_m *UtilsRepo) ToStruct(v map[string]interface{}, r interface{}) error {
	ret := _m.Called(v, r)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, interface{}) error); ok {
		r0 = rf(v, r)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsRepo_ToStruct_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ToStruct'
type UtilsRepo_ToStruct_Call struct {
	*mock.Call
}

// ToStruct is a helper method to define mock.On call
//  - v map[string]interface{}
//  - r interface{}
func (_e *UtilsRepo_Expecter) ToStruct(v interface{}, r interface{}) *UtilsRepo_ToStruct_Call {
	return &UtilsRepo_ToStruct_Call{Call: _e.mock.On("ToStruct", v, r)}
}

func (_c *UtilsRepo_ToStruct_Call) Run(run func(v map[string]interface{}, r interface{})) *UtilsRepo_ToStruct_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}), args[1].(interface{}))
	})
	return _c
}

func (_c *UtilsRepo_ToStruct_Call) Return(err error) *UtilsRepo_ToStruct_Call {
	_c.Call.Return(err)
	return _c
}

// NewUtilsRepo creates a new instance of UtilsRepo. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewUtilsRepo(t testing.TB) *UtilsRepo {
	mock := &UtilsRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
